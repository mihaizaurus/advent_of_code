didn't work, kept for info and analysis of part 2.

loop {
        for &(min, max) in ranges {
            if fresh_ids_ranges.is_empty() { // Initial Push
                fresh_ids_ranges.insert((min, max));
            }
            else { // for each subsequent range
                let mut temp_range_list: HashSet<(usize,usize)> = HashSet::new();
                // check whether min and / or max are within an existing range
                for &existing_range in &fresh_ids_ranges {
                    let (existing_min, existing_max) = existing_range;
                    if existing_min <= min && min <= existing_max { // min is in range
                        if existing_min <= max && max <= existing_max { 
                            temp_range_list.insert((existing_min,existing_max));
                        }
                        else { // only min is contained
                            // new range will have to be from old min to new max
                            temp_range_list.insert((existing_min, max));
                        }
                    }
                    else if existing_min <= max && max <= existing_max { // only max is contained
                        // new range will be from new min to old max
                        temp_range_list.insert((min, existing_max));
                    } else {
                        if  min <= existing_min && existing_max <= max { // new range encompasses old range
                            temp_range_list.insert((min,max));
                        }
                        else { // new range is outside of old range
                            temp_range_list.insert((min,max));
                            temp_range_list.insert((existing_min,existing_max));
                        }
                    }
                }
                modified = !(fresh_ids_ranges.len() == temp_range_list.len());
                // fresh_ids_ranges = compress_ranges(&temp_range_list);
            }
        }
        if !modified {break;}
    }